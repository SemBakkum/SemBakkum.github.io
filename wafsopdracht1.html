<!DOCTYPE html>
<html lang="en">
	<head>
        <meta charset="UTF-8">
        <title>Sem Bakkum Everything Web</title>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <!--[if lte IE 8]><script src="css/ie/html5shiv.js"></script><![endif]-->
        <script src="js/jquery.min.js"></script>
        <script src="js/skel.min.js"></script>
        <script src="js/skel-layers.min.js"></script>
        <script src="js/init.js"></script>
        <noscript>
            <link rel="stylesheet" href="css/skel.css" />
            <link rel="stylesheet" href="css/style.css" />
            <link rel="stylesheet" href="css/style-xlarge.css" />
        </noscript>
        <!--[if lte IE 8]><link rel="stylesheet" href="css/ie/v8.css" /><![endif]-->
    </head>
	<body>

		<!-- De header, met een navigatie -->

		<header id="header">
            <h1><a href="index.html">Sem Bakkum</a></h1>
            <nav id="nav">
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="wafs.html">WAFS</a></li>
                    <li><a href="css.html">CSSTTR</a></li>
                    <li><a href="blog.html">Blog</a></li>
                </ul>
            </nav>
        </header>



		<!-- De main content begint hier -->
		<main>
			<article>
				<header>
					<h1>Exercises 2 & 3</h1>
					<h2>Opdracht 2 Voor-en nadelen JavaScript libraries/frameworks</h2> 
				</header>

				<p>Dankzij een library of framework kan een programmeur sneller en effecienter werken. Doordat er geen honderen regels 
				code meer nodig zijn om tot een gewenst resultaat te komen, maar het zelfde resultaat bereikt kan worden met enkele regels die
				de library aanspreken. Een nadeel hier van is dat je de library taal leert en geen Javascript of andere taal waarop de library 
				gebasseerd is.</p>

				<p>De library is waarschijnlijk beter beveiligd door dat deze gratis te gebruiken is en daarom door meerdere mensen 
				gebruikt wordt. Door het vele gebruik worden lekken in de library eerder aangekaart bij de makers van de library of de community die aan de 
				library werkt. Het nadeel hier van is dat gebruikers de library goed kunnen leren en de fouten niet aangeven bij de makers, maar juist deze 
				fouten tegen de gebruikers gaan gebruiken.</p> 

				<p>Door dat programmeurs dankzij libraries sneller kunnen coderen scheelt dit uiteindelijk in de kosten voor een client. Producten kunnen 
				sneller gemaakt worden waardoor er minder tijd in gestoken hoeft te worden.</p>

				<p>Het nadeel van frameworks/libraries is dat er grenzen zijn aan de mogelijkheden qua coderen. Je hebt je altijd te houden aan wat er
				mogelijk is met de library of het framework. Een framework/library (hoe handig het ook is) biedt beperkingen als je niet de juiste library 
				hebt om je doel te bereiken.</p>

				[bron: http://1stwebdesigner.com/pros-cons-frameworks/]
			</article>

			<article> 
				<header>
					<h2>Opdracht 3 Voor- en nadelen single page web app</h2>

				</header>

				<p>Met een single page website heb je meer controle over de user flow. Door dat een gebruiker alleen maar naar beneden kan scrollen of klikken via het menu kun jij beter bepalen wat de gebruiker te zien krijgt. Zo voorkom je dat bijvoorbeeld bij een multi page website gebruiker sbelangrijke stukken informatie missen of over het hoofd zien. Daarnaast zorg je er bij een single page website ook voor dat de content kort maar krachtig is. Mocht je wel hele lappen tekst en interacties in een one page website verwerken riskeer je een lange laad tijd van de pagina waar door je de gebruiker kwijt kan raken.</p> 

				<p>Een single page website is een goede oplossing voor bedrijven die hun verhaal willen vertellen of personen die hun portfolio willen tonen. Mocht je een bedrijf als amazon zijn dan zul je niet zo snel (of eigenlijk nooit) over gaan op een single page design. De content van een amazon is zo groot dat je een inmens lange pagina zal krijgen waarin je eindeloos zal moeten scrollen. Daarnaast is het voor websites met een stuk minder content effecienter. Door dat je alles op één pagina hebt en niet in verschillende pagina's is de content makkelijker te bewerken en bij te werken.</p>

				<p> Een ander nadeel van een one page website zijn de analytics. In een multi page website kun je zien wat er wel werkt op een pagina, hoe lang de gebruiker op de pagina blijft of hoe snel die juist weer weg gaat. Bij een one page website is dit moeilijk in te schatten. Het enige wta je kunt zien is hoe lang ze blijven en hoe snel sommige weer weggaan. Je weet dus nooit wat er niet werkt in je one page layout en dat laat dus weinig ruimte voor verbetering. De enigste manier om hier achter te komen is door je website te testen bij gebruikers en op basis daarvan verbeteringen te maken.</p>

				[bron: http://www.designagency.co.uk/blog/2015/4/21/the-pros-and-cons-of-single-page-websites]
				[bron: http://cyberchimps.com/one-page-theme/]

			</article>

			<section>
				<h4>Opdracht 4</h4>
				<pre><code>(function () {
	'use strict';

    var et = new EventTarget();

    var config = {
	   linear: 'linear', 
	   gpsAvailable: 'GPS_AVAILABLE',
	   gpsUnavailable: 'GPS_UNAVAILABLE',
	   positionUpdated: 'POSITION_UPDATED',
	   refreshRate: 1000,
	   currentPosition: {
		  currentPositionMarker: false,
		  customDebugging: false,
		  debugId: false,
		  map: false,
		  interval: false,
		  intervalCounter: false,
		  updateMap: false
	   },
	   locationRow: [],
	   markerRow: []
    },

    function EventTarget(){
        this._listeners = {}
    },

    EventTarget.prototype = {
        constructor:EventTarget,
        addListener: function(a,c){
    	   "undefined" === typeof this._listeners[a] && this._listeners[a] === [];
    		  this._listeners[a].push(c);
        },

        fire:function(a){
    	   "string" === typeof a && (a = {
             type: a
            });

    	   a.target || a.target === this;
        },

        fire:function(a){
            "string" === typeof a && (a = {
                type:a
            });

            a.target || (a.target = this);

            if(!a.type)
        	   throw Error("Event object missing 'type' property.");

            if(this._listeners[a.type] instanceof Array)
        	   for(var c = this._listeners[a.type], b = 0, d = c.length; b < d; b++)
        		  c[b].call(this,a)},
        		  removeListener:function(a,c){
        			 if(this._listeners[a] instanceof Array)
        				    for(var b = this._listeners[a], d = 0 , e = b.length; d < e; d++)
        					   if(b[d] === c){
        						  b.splice (d,1); 
        						  break}}}, 

    var geo = {
        init: function (){
            debug_message("Controleer of GPS beschikbaar is...");

            et.addListener(gpsAvailable, _start_interval);
            et.addListener(gpsUnavailable, function(){debug_message('GPS is niet beschikbaar.')});

            (geo_position_js.init())?et.fire(gpsAvailable):et.fire(gpsUnavailable);
        },

    // Start een interval welke op basis van REFRESH_RATE de positie updated
        _startInterval: function(event){
            debug_message("GPS is beschikbaar, vraag positie.");
            _update_position();
            interval = self.setInterval(_update_position, refreshRate);
            et.addListener(positionUpdated, _check_locations);
        },

    // Vraag de huidige positie aan geo.js, stel een callback in voor het resultaat
            _updatePosition: function(){
                intervalCounter++;
                geo_position_js.getCurrentPosition(_set_position, _geo_error_handler, {enableHighAccuracy:true});
            },

    // Callback functie voor het instellen van de huidige positie, vuurt een event af
            _setPosition: function(position){
                currentPosition = position;
                et.fire("POSITION_UPDATED");
                debug_message(intervalCounter + " positie lat:" + position.coords.latitude + " long:" + position.coords.longitude);
            },

    // Controleer de location en verwijs naar een andere pagina als we op een location zijn
            _checkLocations: function(event){
        // Liefst buiten google maps om... maar helaas, ze hebben alle coole functies
                for (var i = 0; i < location.length; i++) {
                    var location = {
                        coords:{
                            latitude: location[i][3],
                            longitude: location[i][4]
                        }};

                    if(_calculate_distance(location, currentPosition) < location[i][2]){

                    // Controle of we NU op die location zijn, zo niet gaan we naar de betreffende page
                        if(window.location != location[i][1] && localStorage[location[i][0]] === "false"){
                        // Probeer local storage, als die bestaat incrementeer de location
                            try {
                                (localStorage[location[i][0]] === "false")?localStorage[location[i][0]] = 1: localStorage[location[i][0]]++;
                            } catch(error) {
                                debug_message("Localstorage kan niet aangesproken worden: "+error);
                            }

    // TODO: Animeer de betreffende marker

                            window.location = location[i][1];
                            debug_message("Speler is binnen een straal van "+ location[i][2] +" meter van "+location[i][0]);
                        }
                    }
                }
            },

    // Bereken het verchil in meters tussen twee punten
            _calculateDistance: function(p1, p2){
                var pos1 = new google.maps.LatLng(p1.coords.latitude, p1.coords.longitude);
                var pos2 = new google.maps.LatLng(p2.coords.latitude, p2.coords.longitude);
                return Math.round(google.maps.geometry.spherical.computeDistanceBetween(pos1, pos2), 0);
            }
        },




    // GOOGLE MAPS FUNCTIES
    /**
     * generate_map(myOptions, canvasId)
     *  roept op basis van meegegeven opties de google maps API aan
     *  om een kaart te genereren en plaatst deze in het HTML element
     *  wat aangeduid wordt door het meegegeven id.
     *
     *  @param myOptions:object - een object met in te stellen opties
     *      voor de aanroep van de google maps API, kijk voor een over-
     *      zicht van mogelijke opties op http://
     *  @param canvasID:string - het id van het HTML element waar de
     *      kaart in ge-rendered moet worden, of
     */

        var map = {
            generateMap: function(myOptions, canvasId){
        // TODO: Kan ik hier asynchroon nog de google maps api aanroepen? dit scheelt calls
                debug_message("Genereer een Google Maps kaart en toon deze in #"+canvasId)
                map = new google.maps.Map(document.getElementById(canvasId), myOptions);

                var routeList = [];
                // Voeg de markers toe aan de map afhankelijk van het tourtype
                debug_message("location intekenen, tourtype is: "+tourType);
                for (var i = 0; i < location.length; i++) {

                // Met kudos aan Tomas Harkema, probeer local storage, als het bestaat, voeg de location toe
                    try {
                        (localStorage.visited === "undefined" || isNumber(localStorage.visited))?localStorage[location[i][0]] = false: null;
                    } catch (error) {
                        debug_message("Localstorage kan niet aangesproken worden: " + error);
                    }

                    var markerLatLng = new google.maps.LatLng(location[i][3], location[i][4]);
                    routeList.push(markerLatLng);

                    markerRow[i] = {};
                    for (var attr in locationMarker) {
                        markerRow[i][attr] = locationMarker[attr];
                    }
                    markerRow[i].scale = location[i][2]/3;

                    var marker = new google.maps.Marker({
                        position: markerLatLng,
                        map: map,
                        icon: markerRow[i],
                        title: location[i][0]
                    });
            }
    // TODO: Kleur aanpassen op het huidige punt van de tour
                if(tourType === linear){
                    // Trek lijnen tussen de punten
                    debug_message("Route intekenen");
                    var route = new google.maps.Polyline({
                        clickable: false,
                        map: map,
                        path: routeList,
                        strokeColor: 'Black',
                        strokeOpacity: .6,
                        strokeWeight: 3
                    });

                }

                // Voeg de location van de persoon door
                currentPositionMarker = new google.maps.Marker({
                    position: kaartOpties.center,
                    map: map,
                    icon: positieMarker,
                    title: 'U bevindt zich hier'
                });

                // Zorg dat de kaart geupdated wordt als het POSITION_UPDATED event afgevuurd wordt
                et.addListener(positionUpdated, update_positie);
                },

                function isNumber(n) {
                return !isNaN(parseFloat(n)) && isFinite(n);
                },

                // Update de positie van de gebruiker op de kaart
                function updatePositie(event){
                // use currentPosition to center the map
                    var newPos = new google.maps.LatLng(currentPosition.coords.latitude, currentPosition.coords.longitude);
                    map.setCenter(newPos);
                    currentPositionMarker.setPosition(newPos);
                }
        },

        var debug = {

            // FUNCTIES VOOR DEBUGGING

            _geoErrorHandler: function(code, message) {
                debug_message('geo.js error '+code+': '+message);
            };
            debugMessage: function(message){
                (customDebugging && debugId)?document.getElementById(debugId).innerHTML:console.log(message);
            };
            setCustomDebugging: function(debugId){
                debugId = this.debugId;
                customDebugging = true;
            };
        }
    })();
</code></pre>
			</section>

		</main>
		<footer>
		</footer>
	</body>
</html>
